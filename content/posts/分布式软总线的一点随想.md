+++
title = "分布式软总线的一点随想"
description = "记录一些分布式软总线的思考以及发散随想"
date = 2025-11-13
draft = false

[taxonomies]
categories = ["随笔"]
tags = ["操作系统","思考碎记"]

[extra]
toc = true
reading_time = true
comment = false
+++

## 故事的起源
> 瞄到一行文字，HarmonyOS与Linux的IPC对比，HarmonyOS会更胜一筹，那么就引发我的好奇了，它为什么会更快呢？

## 思考脉络

### 初窥
先谈谈我的认识，可以第一时间想到的是，他在内核态和用户态的调用和数据搬运做了手脚。

在我们的 Linux 中，进程间通信无外乎六种：`信号`、`信号量`、`消息队列`、`共享内存`、`网络 socket`。  
其中最快的 IPC 当然是共享内存，我也很喜欢这种高风险高回报的操作方式。

我们可以想象一块内存，内核和用户都可以对它进行读写操作，只是需要特判，保证操作同步。

经过起初大致的了解，`HarmonyOS` 采用的就是这种方式，只不过它多了一些特殊的设计：
- 内核采用混合内核的架构，功能边界更在乎用户的体验。
- 对于一块共享内存，创建时由内核完成，但后续操作无需内核辅助，由用户态自发完成。

相比之下，`Linux` 宏内核中，这块共享内存的调度操作都需要内核态确认，有内核作为中间人，很别扭。  
我原本以为，内核和用户态是独立的，内核无需费心，但疑惑仍在：Linux 内核内存极其宝贵，操作也很快，HarmonyOS 适度分离操作权真的能让效率更高吗？

---

### 换个视角
*直觉上，我不认为用户态就会变快，反而会更慢吧？*

延展一下视角，宏内核和混合内核的设计哲学不同：
- 宏内核把所有事务仲裁集中在自己身上
- 混合内核只保留最小核心在内核，其他由用户态实现

因此，对于共享内存链路：
- 完全绕过内核，大部分不走系统调用
- 减少上下文切换
- 可以做到纯粹的零拷贝

与朋友讨论后，我意识到，HarmonyOS 的混合内核内存管理可以理解成 Go 或 Java 的用户态内存管理，思路一致，大部分逻辑在用户态完成。

---

### 延伸
*单机聊过了，但如果有两台或多台机器呢，它又做了什么优化？*

举生活中常见的例子，比如多屏协作、共享：
- HarmonyOS 采用分布式软总线设计
- 将跨设备通信方式（Wi-Fi、蓝牙、TCP 等）统一成 API
- 控制平面对路径评分，尽量走最优数据通路
- 数据平面沿着方向传输数据

举例说明：
- 手机开热点，采用 AP 模式，会做 DHCP、NAT、路由转发
- 经过评估，也可能采用 Wi-Fi Direct 点对点通信，仅需 DHCP 或路由
- 为了统一管理，软总线会套设备号头，进行统一寻址和发现
- TCP/IP、蓝牙、USB、IPC 全都整合成 OS 级“内核通信总线”，再加智能调度算法

> 注：这里的控制平面负责决策，数据平面负责传输，类似“分布式 OS 的通信子系统”，但不是完整分布式操作系统。

---

### 小结
虽然浅谈里没有量化比较，但从设计上可以看出一二：

- **单机高效原因**：用户态零拷贝、少上下文切换
- **跨机高效原因**：统一通信总线 + 控制平面智能调度
- **设计哲学**：混合内核重体验，宏内核仲裁更安全
